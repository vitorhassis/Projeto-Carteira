PROJETO FULL STACK PASSO A PASSO EM SEQUENCIA
1-CRIANDO PROJETO
2-CRIANDO A CLASSE
3-DBCONTEXT
4-CRIAR O APPDBCONTEXT
5-CRIAR A CONEXAO NO BANCO DE DADOS
6-CONFIGURAR O PROGRAM.CS
7-RESUMO
8-BANCO DE DADOS CRIADO
9-PASTA CONTROLLERS/TRANSACOESCONTROLLER.CS
    ->DEFINIÇÃO DO CONTROLLER
    ->CONSTRUTOR


ENTENDENDO FLUXO DO PROJETO (APPDBCONTEXT.CS - TRANSACOESCONTROLLER.CS)
    ->USER FAZENDO UMA REQUISIÇÃO
CONHECIMENTO 
    ->RELACAO ENTRE DBCONTEXT E EFCORE


1-CRIANDO PROJETO
-fomos no visual studio installer -> selecionamos "ASP.NET e desenvolvimento web" e instalamos;
-dentro do projeto, estão todos os arquivos da API;
---------------------
->Connected Services
-usado para integrar serviços externos, como API REST, etc;
---------------
->Dependências
-mostra as referencias do projeto;
------------
->Properties
-contem configurações do projeto;
-launchsettings.json -> configura o modo de execução;
-------------
->Controllers
-onde ficam os controllers da sua API;
-Por padrão, já vem com WeatherForecastController.cs que eh um exemplo de controller que responde a uma rota;
------------------
->appsettings.json
-arquivo de configuração do seu projeto;
-aq q configura a connection string do banco (mySQL ou SQL Server), configurações de logging, outros ajustes;
----------------------
->CarteiraSimples.http 
-arquivo de teste de requisições HTTP integrado ao Visual Studio;
-você pode simular GET, POST direto dali;
-------------
->Program.cs
-arquivo que define como a aplicação inicia;
--------------------
->WeatherForecast.cs
-classe de modelo doe exemplo, relacionada ao WeatherForecastController.cs
-------------------------------------------------------------------------------------------------------------------
2-CRIANDO A CLASSE 
-Agora, vamos criar a classe que sera usada como modelo (Model) da nossa aplicação;
-criamos uma pasta chamada "Models". Aqui dentro, vamos criar uma classe chamada Transacao.cs;

ATRIBUTOS
-os atributos serão ID, Valor, Nome, Data, Descricao, Tipo;

EXEMPLO
namespace CarteiraSimples.Models
{
    public class Transacao
    {
        public int Id { get; set; }
        public double Valor { get; set; }
        public string Descricao { get; set; }
        public string Tipo { get; set; }
        public DateTime Data { get; set; }
    }
}
-basicamente estruturei como a tabela no banco de dados sera;
-------------------------------------------------------------------------------------------------------------------3-DBCONTEXT
-Classe base que gerencia (vai e volta), que faz a ponte entre o C# e o banco de dados;
-eh uma classe generica. Voce cria uma classe filha para personalizar o contexto, para dizer exatamente quais classes irao virar tabelas no banco de dados;
-------------------------------------------------------------------------------------------------------------------
4-CRIAR O APPDBCONTEXT (CLASSE HERDADA)
-PONTE REAL COM O BANCO. ELE RECEBE UMA ORDEM DO 'TRANSACOES.CONTROLLER' SOBRE OQ ELE VAI FAZER (CRUD) NO BANCO*
-Classe filha personalizada da DbContext;
-Ela atua como uma sessão com o banco de dados. Tudo o que fizermos no C# para consultar, add, atualizar, deletar dados passará por uma instancia dessa classe;

ESTRUTURA
-crie uma pasta chamada Data;
-crie um arquivo chamado "AppDbContext.cs";

COMO FAZER
-trate a sua classe criada como uma classe filha de "DbContext". Ou seja, estamos fazendo com que a nossa classe herde funcionalidades da classe DbContext, q eh a base para mapear e manipular dados no banco;

ESTRUTURA/ENTENDENDO O CODIGO
using Microsoft.EntityFrameworkCore;
using CarteiraSimples.Models;

namespace CarteiraSimples.Data
{
    public class AppDbContext : DbContext
    {
        public AppDbContext(DbContextOptions<AppDbContext> options) : base(options) { }

        public DbSet<Transacao> Transacoes => Set<Transacao>();
    }
}
-A classe tem um construtor, que sempre que essa classe for instanciada será passada para ela um parâmetro, o options, que possui as configurações do banco de dados;
-qm cria e entrega esse 'options' eh o sistema do ASP.NET, através de um conceito chamado 'injeção de dependência';
-esse 'options' eh passado para a classe base, a DbContext;
-a classe base, o DbContext que faz parte do EF Core, eh a maquina que gerencia a comunicação com o banco de dados;
-a classe base le 'options' para saber com qual banco estamos lidando, e outras configurações desse banco;


public DbSet<Transacao> Transacoes => Set<Transacao>()
-<Transacao> eh o nome da classe no C#;
-Transacoes = Representa a tabela real no banco de dados;
-o DbSet eh uma ferramenta do EFCore que transforma sua classe C# <Transacao> em algo que pode ser armazenado e consultado no banco de dados;
-Set<Transacao>() = eh oq permite usar os comandos do EFCore, como .Add(), .Remove(), etc. Ele conecta o seu código a tabela, e fornece as funções de CRUD;
-------------------------------------------------------------------------------------------------------------------
5-CONEXAO COM O BANCO DE DADOS
->PRIMEIRO PASSO
-ter o MySQL rodando (verifique se o XAMPP esta ativo);
-abre o workbench e cria uma nova conexão;

->APPSETTINGS.JSON
-arquivo de config do projeto ASP.NET Core;
-ele serve para guardar endereço do banco de dados, API externas, etc;
-vamos fazer algumas mudanças aqui. No caso, add o "ConnectionStrings", que são as informações que dizem ao projeto, como se conectar ao banco de dados;


VAI ESTAR ASSIM:
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },
  "AllowedHosts": "*"
}

ADICIONANDO ISSO:
'CONNECTIONSTRINGS' = onde o ASP.NET busca as configurações de conexão do banco;
'DEFAULTCONNECTION: "server=localhost;database=carteiraSimples_DB;user=root;password" = 
-DEFAULTCONNECTION = nome que usamos no Program.cs para injetar o AppDbContext;
-"server = localhost" = diz pro EF Core usar o MySQL local do XAMPP;
-"database=carteiraSimples_DB" = nome do banco criado no workbench;
"user=root;password=" = credenciais do MySQL;

FICARA ASSIM:
{
  *"ConnectionStrings": {
    *"DefaultConnection": "server=localhost;database=carteiraSimples_DB;user=root;password="
  },

  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },

  "AllowedHosts": "*"
-------------------------------------------------------------------------------------------------------------------
6-CONFIGURANDO O PROGRAM.CS
-No `Program.cs`, está o esqueleto básico de uma API, ou seja, a configuração mínima necessária para rodar uma aplicação ASP.NET Core. Nele, registramos uma instância da classe criada, `AppDbContext`. Como o construtor dessa classe exige o parâmetro `options`, usamos ele para passar as configurações do banco de dados que definimos no `appsettings.json` (as `ConnectionStrings`). Assim, essas configurações são enviadas para a classe base `DbContext`, que faz toda a ponte entre o C# e o banco de dados;
-Dessa forma, estaremos ativando o banco da API;
-------------------------------------------------------------------------------------------------------------------
7-CRIANDO O ARQUIVO APPDBCONTEXTFACTORY.CS
-Basicamente, o AppDbContextFactory serve para quando o Entity Framework precisa de uma instância do AppDbContext (por exemplo, pra criar tabelas ou aplicar migrações), mas a aplicação não está em execução. Nesse caso, o código da factory permite que o EF crie essa instância manualmente, sem precisar que você esteja rodando o projeto (dotnet run);
-------------------------------------------------------------------------------------------------------------------
8-BANCO DE DADOS CRIADO
-Só iniciar o xampp e abrir o Workbench que vai estar lá;
-------------------------------------------------------------------------------------------------------------------
9-PASTA CONTROLLERS/TRANSACOESCONTROLLER.CS
-O 'TRANSACOESCONTROLLER' INFORMA PRO 'APPDBCONTEXT' A OPERAÇÃO QUE ELE VAI TER Q FAZER*
-vamos criar a pasta 'Controllers' e o arquivo 'TransacoesController.cs'. Esse 'Controller' vai expor os 'enpoints' da API;
-o ENDPOINT é um endereço que permite acessar ou alterar dados do banco, de forma controlada e segura;
-eu tenho tipo de ENDPOINTS. GET (busca dados, sem alterar nada) POST (cria um novo registro no banco), PUT (atualiza um registro existente) DELETE (remove um registro do banco);
-cada tipo de ENDPOINT representa um tipo de operação que a API consegue fazer sobre os dados do banco;
-no caso, o back-end que faz as operações de verdade. Ele é quem executa os comandos no banco;
-------------------------
->DEFINIÇÃO DO CONTROLLER
-aqui, estamos configurando e avisando pro ASP.NET CORE que essa classe eh um controller de API, e tudo oq estiver dentro dela (métodos) vai responder requisições HTTP para /api/transações;

namespace CarteiraSimples.Controllers
{
    [ApiController] 
    [Route ("api/[controller]")]
    
    public class TransacoesController : ControllerBase {
    }
    
}
-[ApiController] = diz pro ASP.NET que essa classe eh um controler da API;
-[Route ("api/[controller]")] = //define a rota base dos endpoints ([controler] eh substituido pelo nome da classe, sem o 'Controller'. Ou seja, resultado final = /api/transações;
-public class TransacoesController : ControllerBase = cria a classe base do controller, herda recursos do ASP.NET pra responder requisicoes HTTP;
------------
->CONSTRUTOR
-so pra lembrar, o construtor eh um método especial que eh executado EXATAMENTE quando a classe eh criada. Ela serve para inicializar atributos, preparar o objeto para funcionar;
-nesse caso, o ASP.NET CORE quando recebe uma requisição na rota /api/transações, precisa criar uma INSTANCIA dessa classe, para tratar essa requisição. Para isso, ele olha para o construtor e ve oq essa classe precisa. No caso:

private readonly AppDbContext _context;
public TransacoesController(AppDbContext context)
{
    _context = context; 
}
-primeiro, cria-se uma variável privata e IMUTÁVEL que guarda a conexão com o banco, protegendo-a de alterações;
-o construtor diz ao ASP.NET Core que, toda vez que for feita uma requisição API (como uma operação de CRUD), essa classe precisa receber um objeto do tipo AppDbContext, que representa a conexão e o canal de comunicação com o banco de dados= - e eh ele quem executa de fato as ações de CRUD. O 'controller'. apenas usa instancia do 'AppDbContext', guardada em '_contexto', para solicitar que tais operações sejam realizadas;

-Agora, vamos criar os métodos que são o coração do controller. Eles são o que permitem o front falar com o banco;
----------------
->ENDPOINT - GET 
-o método GET, vai buscar TODAS as transações no banco e devolver em formato JSON para quem chamou a API;

[HttpGet]
public async Task<ActionResult<IEnumerable<Transacao>>> GetTransacoes()
{
    return await _context.Transacoes.ToListAsync();
}

-[HttpGet] = diz ao ASP.NET que esse método responde a requisições HTTP GET (consulta de dados);

*public async Task<ActionResult<IEnumerable<Transacao>>> GetTransacoes()*
 -public async = declaramos como 'async', ou seja, apesar dele precisar de uma resposta do banco, não é pra travar a aplicação;
-IEnumerable<Transacao> = significa uma "coleção de transações", ou seja, varias linhas da tabela 'Transacoes', msm coisa que retornar uma lista de objetos 'Transacao';
-ActionResult<IEnumerable<Transacao>> = "Vou devolver uma resposta HTTP com algum conteúdo", mas ele também permite devolver status de erros. Ou seja, ele diz "Essa ação pode retornar uma lista de transações ou uma mensagem de erro HTTP";
-Task<...> = o método usa 'async', oq significa que ele roda de forma assíncrona. Todo método 'async' precisa retornar uma Task que representa uma operação que vai terminar no futuro. 'Task' eh uma promessa de que o resultado virá depois que o banco responder;

*return await _context.Transacoes.ToListAsync()*
-.ToListAsync() = manda o EF Core buscar todos os registros dessa tabela e retornar como uma lista;
-.Transacoes.ToListAsync() = representa a tabela 'Transacoes' no banco;
-_context.Transacoes.ToListAsync() = é a instancia do AppDbContext, a ponta com o banco de dados;
------------------------
->ENDPOINT - GET PELO ID
-aqui, a função retorna apenas uma transação específica pelo seu ID;
-usa o 'FindAsync(id)' para procurar uma linha com esse ID no banco de dados;

[HttpGet("{id}")]
public async Task<ActionResult<Transacao>> GetTransacao(int id)
{
    var transacao = await _context.Transacoes.FindAsync(id);

    if (transacao == null)
    {
        return NotFound();
    }

    return transacao;
}
-[HttpGet("{id}")] = atributo de rota. "Quando alguém fizer um GET com um parâmetro na URL, chame esse método";
*public async Task<ActionResult<Transacao>> GetTransacao(int id)*
-public pq eh um método publico, async pq eh um método assíncrono, ou seja, ele não bloqueia a execução enquanto acessa o banco de dados, e o Task<ActionResult<Transacao>> é o tipo de retorno, 'Task' significa que o método retorna uma tarefa assíncrona, 'ActionResult<Transacao>' significa que o resultado da tarefa vai ser uma resposta HTTP, contendo um objeto de Transação se tudo der certo, ou um status HTTP se algo der errado. 'GetTransacao' eh o nome da função, e o 'int id' eh o parâmetro recebido da URL;

*var transacao = await _context.Transacoes.FindAsync(id)*
-a linha acima busca no banco de dados, de fome assíncrona, uma transação com o ID informado, e guarda o resultado (se existir) na var 'transacao';

-dps so fazemos um if para verificar oq foi retornado para a var 'transacao'. Se for nulo, trata o erro, se não, ou seja, retornou um ID do banco, retorne ele;
-------------------
->ENDPOINT - POST -

[HttpPost]
public async Task<ActionResult<Transacao>> PostTransacao(Transacao transacao)
{
    _context.Transacoes.Add(transacao);      
    await _context.SaveChangesAsync();       

    return CreatedAtAction(nameof(GetTransacao), new { id = transacao.Id }, transacao);
}

*public async Task<ActionResult<Transacao>> PostTransacao(Transacao transacao)*
-função que né, vai ser pública, assíncrona porque espera uma requisição do banco de dados, mas não quer que trava o sistema por conta disso, task porque retorna uma tarefa assíncrona, e 'ActionResult' porque o resultado vai ser uma resposta HTTP, contendo um objeto de 'Transacao' ou um erro esperado;
-O nome da função eh 'PostTransacao', e ela recebe como parâmetro um objeto de Transação, chamado 'transacao';

*_context.Transacoes.Add(transacao)*
-'context' eh um objeto do tipo 'AppDbContext' que representa a ponte com o banco de dados. o '.Transacoes' representa a tabela dentro do banco. Estou basicamente adicionando na tabela, o que é passado como parâmetro da função, ou seja, um objeto 'transacao', adicionando uma nova linha no banco de dados. Mas aqui ainda ele não grava de verdade, ele só PREPARA o ambiente para ser salvo;

*await _context.SaveChangesAsync()*
-aqui sim, o EFCore envia o comando 'INSER INTO' pro banco MySQL;

*return CreatedAtAction(nameof(GetTransacao), new { id = transacao.Id }, transacao)*
-Essa linha retorna a resposta 201 Created, indicando sucesso na criação, informando onde o novo item pode ser encontrado (/api/transacoes/{id}) e enviando o objeto completo de volta no corpo da resposta;

*OBS*
-quando uso o .Add, o EFCore ja marca automaticamente o estado do objeto como 'Added'. O metodo usado (.Add) ja diz isso para ele. Ele ja sabe que vai ter que gerar um INSERT (no PUT, eu preciso informar pro EFCore que ele vai precisar dar um UPDATE quando for salvo, alterando o status da entidade para '.Modified');
------------------------------------------
->PUT - ATUALIZAR UMA TRANSACAO EXISTENTE - 

[HttpPut("{id}")]
public async Task<IActionResult> PutTransacao(int id, Transacao transacao)
{
    if (id != transacao.Id)
    {
        return BadRequest(); // se o id da URL for diferente do objeto recebido
    }

    _context.Entry(transacao).State = EntityState.Modified; // marca o objeto como alterado

    try
    {
        await _context.SaveChangesAsync(); // salva as mudanças no banco
    }
    catch (DbUpdateConcurrencyException)
    {
        if (!_context.Transacoes.Any(e => e.Id == id))
        {
            return NotFound(); // se o id não existe no banco
        }
        else
        {
            throw;
        }
    }

    return NoContent(); //"A atualização foi feita com sucesso, mas não tem nada pra retornar no corpo da resposta"
}

-[HttpPut("{id}")] = Indica que esse método responde a requisições PUT, com um parâmetro na URL (id);

*public async Task<IActionResult> PutTransacao(int id, Transacao transacao)*
-'PutTransacao' eh o nome do método q eh assíncrono, por isso usamos o 'await' dentro dele, e pq o tipo do retorno, eh uma tarefa, que eh uma resposta HTTP genérica (<IActionResult>) que pode ser qualquer coisa, como 'ok()', 'NotFound()', etc;
-esse método recebe dois parâmetros. No caso o ID da transação que queremos atualizar, e um objeto 'transacao' de Transação que representa os novos dados;

*if (id != transacao.Id)
    {
        return BadRequest(); // se o id da URL for diferente do objeto recebido
    }*
-esse if, eh uma verificação pra garantir que o registro que queremos atualizar, eh o mesmo que estamos enviando no JSON, para que por exemplo, voce informa o ID 5 (quero atualizar ele) mas esta enviando os dados do item 8, o que eh incoerente. Se for diferente, ele retorna o 'BadRequest()' = retorna erro 400, que indica um erro na requisição;

 *_context.Entry(transacao).State = EntityState.Modified*
-'_context.Entry(transacao).State' = Significa que eu estou entrando (.Entry) no 'context' (representa a conexão com o banco), e quero acessar o estado daquela entidade. Quero definir o estado para '.Modified', ou seja, quero q essa entidade tenha como status, modificado. Isso indica que, quando eu mandar salvar (SaveChangeAsync()), o EFCore vai gerar um UPDATE e atualizar o registro que já existe no banco com o mesmo ID;

*try
{
    await _context.SaveChangesAsync(); 
}
catch (DbUpdateConcurrencyException)
{
    if (!_context.Transacoes.Any(e => e.Id == id))
    {
        return NotFound(); // se o id não existe no banco
    }
    else //"se o erro não for pq o ID não existe, não sei o motivo e joga um erro genérico"
    {
        throw; 
    }
}*
-faco um try catch (try-catch eh sempre usado para evitar que a aplicação quebre se der erro ao salvar). No try, ele TENTA salvar as alterações no banco (executar o UPDATE), eo catch trata, num bloco de codigo, algum erro. Tipo se o registro que voce tentou atualizar nao existe no banco (if(!_context.Transacoes.Any(e => e.Id ==id) no caso '_context.Transacoes' eh a tabela Transacoes no banco, '.Any(...)' eh um metodo que retorna TRUE se existe pelo menos um registro que atenda a condicao. e o 'e => e.Id == id' eh uma expressao lambda que diz para procurar uma transacao, cujo ID seja igual ao ID recebido no parametro)), retornando 'NotFound()' = ID nao encontrado;
----------------------------------------
->DELETE (remove uma transacao do banco)

// DELETE: api/transacoes/5
[HttpDelete("{id}")]
public async Task<IActionResult> DeleteTransacao(int id)
{
    var transacao = await _context.Transacoes.FindAsync(id);
    if (transacao == null)
    {
        return NotFound(); // 404 se o ID não existir
    }

    _context.Transacoes.Remove(transacao); // marca o objeto pra exclusão
    await _context.SaveChangesAsync();     // executa o DELETE no banco

    return NoContent(); // 204 - exclusão feita com sucesso
}

*var transacao = await _context.Transacoes.FindAsync(id)* = estou buscando de forma assincrona, no banco de dados, (via _context q eh a conexao com ele), dentro da tabela 'Transacoes' o registro cujo o ID seja igual ao valor passado como parametro. O resultado eh armazenado na variavel 'transacao'o ID passado como parametro na tabela 'Transacoes' na conexao com o banco de dados (_context) e armazenando o retorno disso na variavel 'transacao';

-o if, verifica se a transacao eh nulo, ou seja, o ID nao existe (NotFound()). Se a transacao existir, (continua o codigo ali abaixo), eu marco esse objeto 'transacao' como "deve ser excluido" da tabela 'Transacoes', atraves da conexao '_context' (que faz a ponte com o banco). Quando tu chama o .Remove() ele muda o estado do objeto para ".Deleted", ou seja, "esse objeto representa um registro existente e que deve ser deletado assim que eu salvar". Por isso sempre, vc faz o 'await _context.SaveChangesAsync()', que eh pra ele executar salvar e executar o DELETE (nesse caso) no banco;


-------------------------------------------------------------------------------------------------------------------
ENTENDENDO FLUXO DO PROJETO (APPDBCONTEXT.CS - TRANSACOESCONTROLLER.CS)
->USER FAZENDO UMA REQUISIÇÃO
-usuário quer ver todas as transações. O navegador manda GET/api/transações;
-o ASP.NET pensa "Essa rota pertence ao controller TransacoesController";
-o ASP.NET cria o controller, ele precisa de um TransacoesController para processar essa rota. Mas ele ve o construtor, e percebe que para isso, ele precisa criar antes um AppDbContext (atua como uma ponte entre o código e o banco de dados);
-como no program.cs configuramos, o ASP.NET já sabe como criar o 'AppDbContext'. Sendo assim, ele já instancia o objeto, conecta com o banco, e deixa tudo pronto para uso;
-o ASP.NET injeta '_context' no controller, que guarda a instancia do AppDbContext;
-Quem faz de fato as mudanças no banco, eh o AppDbContext. O 'Controller' apenas manda ele fazer;
-------------------------------------------------------------------------------------------------------------------
CONHECIMENTO 
->RELACAO ENTRE DBCONTEXT E EFCORE
-O Entity Framework Core (EF Core) é um framework que conecta o C# ao banco de dados sem precisar escrever SQL. O DbContext é a classe principal do EF Core e faz essa ponte, transformando os comandos do C# em ações reais no banco, como inserir, buscar ou excluir dados.
